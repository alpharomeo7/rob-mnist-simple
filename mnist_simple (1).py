# -*- coding: utf-8 -*-
"""mnist_simple.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AqZLbxQMYGDm6J-OizsYjX3-q9GpBH6z
"""

# #get data
# import tensorflow as tf
# # Download the data set

# mnist = tf.keras.datasets.mnist
# (x_train, y_train),(x_test, y_test) = mnist.load_data()

#!unzip data.zip

import numpy as np
import json
import tensorflow as tf

x_train = np.loadtxt('data/x_train.np')
y_train = np.loadtxt('data/y_train.np')
x_test = np.loadtxt('data/x_test.np')
y_test = np.loadtxt('data/y_test.np')

x_train =  x_train.reshape((x_train.shape[0], 28, 28))
x_test =  x_test.reshape((x_test.shape[0], 28, 28))

#Initilaze the model
model = tf.keras.models.Sequential()

# Convert the 28x28 image to 1x764 vector
model.add(tf.keras.layers.Flatten())

# Layer of 128 neurons with sigmoid acitvation function
model.add(tf.keras.layers.Dense(128, activation='sigmoid'))
model.add(tf.keras.layers.Dropout(0.2))

# Output layer
# 10 classes, so 10 neurons
# Softmax since âˆ‘ neurons = 1
model.add(tf.keras.layers.Dense(10, activation='softmax'))

# Compile the model so we can use that
# Tells tf that we are done adding layers
# Gives other info to tf, like optimizer and loss func
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

#training
model.fit(x_train, y_train, epochs=5, validation_data=(x_test, y_test))

model.save('model')

!zip -r model.zip model

#testing
result = model.evaluate(x_test, y_test)

result #[loss, accuracry]

#useful features if we need to save
with open("results/model_summary.txt", "w") as fh:
    # Pass the file handle in as a lambda function to make it callable
    model.summary(print_fn=lambda x: fh.write(x + '\n'))

result_dict = {"loss" : result[0],
               "accuracy": result[1],
               "num_params": model.count_params()}
               
json_object = json.dumps(result_dict, indent=4)
 
# Writing to sample.json
with open("results/result_.json", "w") as outfile:
    outfile.write(json_object)